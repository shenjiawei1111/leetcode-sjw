# LeetCode 解题记录

这是我在 LeetCode 上刷题的解题记录仓库，包含各种算法和数据结构相关题目的解答。

## 项目结构
## 学习日志

### 8月23日
- **学习内容**：哈希表
- **完成题目**：LeetCode 热题 100
  1. 两数之和：使用哈希表存储已遍历过的数字及其索引，对于每个数字，检查目标值与当前数字的差值是否在哈希表中，若存在则返回对应索引。
  2. 字母异位分组：将每个字符串排序后作为键，原字符串作为值存入哈希表，最后收集所有值即可得到分组结果。
  3. 最长连续序列：先将所有数字存入集合，遍历每个数字时，若该数字的前一个数不在集合中，则开始向后查找连续的数字，统计最长长度。

### 8月24日
- **学习内容**：双指针
- **完成题目**：LeetCode 热题 100
  1. 移动零：使用双指针，一个指针遍历数组，另一个指针记录非零元素的位置，将非零元素移到前面，最后将剩余位置置零。
  2. 盛最多水的容器：使用左右双指针，计算当前面积，然后移动较短的指针，不断更新最大面积。
  3. 三数之和：先排序，固定一个数，使用左右双指针在剩余数组中找和为目标值的两个数，注意跳过重复元素。
### 8月25日

- **学习内容**：滑动窗口
- **完成题目**：
  1. 无重复字符的最长子串：使用滑动窗口和哈希集合来解决。维护一个滑动窗口表示当前无重复字符的子串，右指针不断向右移动，将字符加入集合，若遇到重复字符，则移动左指针并从集合中移除字符，直到重复字符被移除，同时更新最长子串的长度。
  2. 找到字符串中所有字母异位词：使用滑动窗口和哈希表来统计字符频率。先统计模式串的字符频率，然后在主串上使用固定大小的滑动窗口，统计窗口内字符频率，若与模式串频率一致，则记录窗口起始位置。
### 8月26日
- **学习内容**：子串题型、链表
- **完成题目**：
  1. 和为k的子数组：使用前缀和与哈希表来解决。遍历数组，计算当前的前缀和，将前缀和出现的次数记录在哈希表中。对于每个前缀和，检查前缀和减去k的值是否在哈希表中，若存在则将对应次数累加到结果中，最后更新当前前缀和的出现次数。
  2. 相交链表：有多种解法，一种方法是使用双指针。分别让两个指针从两个链表头开始遍历，当一个指针到达链表末尾时，将其重定向到另一个链表的头节点。这样两个指针会在相交节点相遇，若不相交则最终都为null。

### 8月27日
- **学习内容**：普通数组、链表
- **完成题目**：
  1. 最大子数组和：使用动态规划来解决。遍历数组，维护一个当前最大子数组和变量，对于每个元素，决定是将其加入当前子数组还是以该元素开始新的子数组，同时更新全局最大子数组和。
  2. 回文链表：先找到链表的中间节点，然后反转后半部分链表，再将前半部分和反转后的后半部分逐一比较节点值，若都相同则为回文链表，比较完成后可按需恢复链表结构。
  3. 反转链表：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
### 8月28日
- **学习内容**：链表操作、数组合并
- **完成题目**：
  1. 反转链表1：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
  2. 反转链表2：此问题是反转链表的进阶版，通常需要先定位到需要反转的区间，再利用类似反转链表1的方法对该区间内的节点进行反转，注意处理好区间首尾节点与其他部分的连接。
  3. 环形链表：使用快慢指针的方法，快指针每次移动两步，慢指针每次移动一步。若链表中存在环，快指针最终会追上慢指针；若不存在环，快指针会先到达链表末尾。
  4. 合并数组：根据数组是否有序有不同的处理方式。若数组有序，可以使用双指针法，分别从两个数组的起始位置开始比较元素大小，将较小的元素依次放入新数组或目标数组中；若数组无序，可能需要先排序再合并，或者根据具体需求采用其他策略。

### 9月2日
- **学习内容**：数组轮转、数组乘积、链表求和
- **完成题目**：
  1. 轮转数组：可以通过三次反转数组来实现。先反转整个数组，再反转前 k 个元素，最后反转剩下的元素，这样就能得到数组轮转 k 次后的结果，其中 k 需要对数组长度取模以避免不必要的操作。
  2. 除自身以外数组的乘积：使用前缀积和后缀积的方法。先计算每个位置的前缀积，即该位置之前所有元素的乘积，再计算每个位置的后缀积，即该位置之后所有元素的乘积，最后将对应位置的前缀积和后缀积相乘，就可以得到除自身以外数组的乘积，且不需要额外的空间复杂度。
  3. 链表的两数之和：从两个链表的头节点开始遍历，逐位相加节点的值，并考虑进位。创建一个新的链表来存储相加的结果，若其中一个链表遍历完，另一个链表还有剩余节点，则继续处理剩余节点并加上进位，最后若还有进位则在结果链表末尾添加一个值为 1 的节点。

### 9月3日
- **学习内容**：二叉树的结构和四种遍历方式
- **完成题目**：
  1. 二叉树的中序遍历：可以使用递归或迭代的方法。递归方法直接按照左子树 - 根节点 - 右子树的顺序递归遍历；迭代方法使用栈来模拟递归过程，先将左子节点不断入栈，直到左子节点为空，然后弹出栈顶节点访问，再处理其右子节点。
  2. 二叉树的最大深度：可以使用递归或广度优先搜索（BFS）的方法。递归方法中，树的最大深度等于左子树和右子树最大深度的最大值加 1；BFS 方法使用队列进行层序遍历，每遍历一层深度加 1，直到队列为空。
### 9月4日
- **学习内容**：二叉树的反转与对称判断
- **完成题目**：
  1. 反转二叉树：可以使用递归或迭代的方法。递归方法是交换当前节点的左右子树，然后递归地对左右子树进行同样的操作；迭代方法可使用队列或栈，将节点依次放入容器中，每次取出一个节点并交换其左右子树，直到容器为空。
  2. 对称二叉树：可以使用递归或迭代的方法。递归方法中，判断左右子树是否对称，需要比较左子树的左节点和右子树的右节点，以及左子树的右节点和右子树的左节点是否对称；迭代方法使用队列或栈，将对应的节点成对放入容器中，每次取出一对节点进行比较，若不相等则不对称，直到容器为空。
### 9月5日
- **学习内容**：二叉树的层序遍历、二叉树的直径计算
- **完成题目**：
  1. 二叉树的层序遍历：使用广度优先搜索（BFS）的方法。借助队列来实现，先将根节点入队，然后不断从队列中取出节点，访问该节点，并将其左右子节点依次入队，直到队列为空。为了区分每一层的节点，可以在每次处理一层节点前记录当前队列的大小，处理完这一层的所有节点后再处理下一层。
  2. 二叉树的直径：可以使用递归的方法。二叉树的直径定义为树中任意两个节点路径长度中的最大值，而这条路径可能不经过根节点。递归计算每个节点的左右子树的最大深度，直径等于左右子树最大深度之和，在递归过程中更新全局最大直径。
### 9月6日
- **学习内容**：二叉搜索树
- **完成题目**：
  1. 二叉搜索树：构建二叉搜索树，插入节点时，若插入值小于当前节点值，则插入到左子树；若大于当前节点值，则插入到右子树。
  2. 验证二叉搜索树：可以使用递归或中序遍历的方法。递归方法需要传递上下界，确保每个节点的值在合法范围内；中序遍历二叉搜索树会得到一个严格递增的序列，可通过判断遍历结果是否递增来验证。

### 9月8日
- **学习内容**：二叉搜索树、二叉树右视图
- **完成题目**：
  1. 二叉搜索树中第k个元素：利用中序遍历的方法，因为二叉搜索树的中序遍历结果是一个严格递增的序列，即按照左子树 - 根节点 - 右子树的顺序遍历。在遍历过程中记录遍历节点的数量，当遍历到第k个节点时，该节点的值就是所求的第k个元素。
  2. 二叉树的右视图：使用层序遍历的方法。借助队列实现层序遍历，在每次处理一层节点时，将该层的最后一个节点（即最右边的节点）的值记录下来，直到队列为空，最终记录的值按顺序排列就是二叉树的右视图。
### 9月9日
- **学习内容**：二叉树展开、二叉树构造
- **完成题目**：
  1. 二叉树展开为链表：把根节点的右子树挂到左子树最右边的断点，再把左子树换到根节点的右子树位置，依次往下处理。
  2. 从前序与中序遍历序列构造二叉树：用前序遍历序列确定根节点，再利用中序遍历序列划分左右子树，递归构建二叉树。
### 9月10日
- **学习内容**：二叉树路径总和、二叉树的公共祖先
- **完成题目**：
  1. 二叉树路径总和：使用二层递归嵌套的方法。外层递归用于移动 `root` 节点，内层递归计算从每个节点出发能达到指定路径和的个数。
  2. 二叉树的公共祖先：采用从上到下递归遍历的方法。先判断每个根节点是否为 `p` 和 `q`，若不是，则判断其左右子节点与 `p`、`q` 的关系。
### 9月11日
- **学习内容**：链表删除、链表交换
- **完成题目**：
  1. 删除链表的倒数第N个结点：使用快慢指针的方法，借助哨兵节点简化头节点处理，快指针先走n步，然后慢指针和快指针一起移动，当快指针为null时，慢指针所指节点的下一个节点就是要删除的节点。
  2. 两两交换链表的节点：借助哨兵节点简化头节点处理，本质是简单的链表指向操作，通过调整相邻节点的指针指向完成交换。
  
### 9月12日
- **学习内容**：链表排序、随机链表复制
- **完成题目**：
  1. 排序列表：将链表节点的值提取到列表中，对列表进行排序，再根据排序后的列表重新构建链表。
  2. 随机链表的复制：使用哈希表存储原节点和对应的新节点。遍历原链表，先创建新节点并与原节点建立映射关系，再遍历一次原链表，根据哈希表为新链表的节点接上正确的指针，包括 next 和 random 指针。
### 9月13日（请根据实际日期修改）
- **学习内容**：栈的应用
- **完成题目**：
  1. 有效的括号：使用栈和哈希表来解决。首先创建一个哈希表，将右括号作为键，对应的左括号作为值。遍历字符串，若遇到左括号则将其压入栈中；若遇到右括号，判断栈顶元素是否为该右括号对应的左括号，若是则弹出栈顶元素，否则返回无效。遍历结束后，若栈为空则字符串有效，否则无效。
  2. 字符串解码：使用栈来解决。遍历字符串，当遇到数字时，解析出完整的数字作为重复次数；当遇到 '[' 时，将当前解析的字符串和重复次数压入栈中，并重置当前字符串；当遇到 ']' 时，弹出栈顶的重复次数和之前的字符串，将当前字符串重复相应次数后拼接到之前的字符串后面；当遇到普通字符时，直接添加到当前字符串。最终得到解码后的字符串。

### 9月14日（请根据实际日期修改）
- **学习内容**：栈的应用
- **完成题目**：
  1. 每日温度：使用单调栈来解决。遍历温度数组，维护一个栈存储数组的索引，栈中索引对应的温度是单调递减的。对于每个温度，如果当前温度大于栈顶索引对应的温度，就计算当前索引与栈顶索引的差值，这个差值就是栈顶索引对应的温度需要等待的天数，然后弹出栈顶元素，直到不满足条件或栈为空，最后将当前索引入栈。
  2. 最小栈：设计一个栈结构，除了支持常规的栈操作外，还能在常数时间内获取栈中的最小元素。可以使用辅助栈来实现，辅助栈的栈顶始终保存当前栈中的最小元素。入栈时，如果新元素小于等于辅助栈栈顶元素，则将新元素也压入辅助栈；出栈时，如果出栈元素等于辅助栈栈顶元素，则辅助栈也弹出栈顶元素。
### 9月15日
- **学习内容**：位运算、投票算法
- **完成题目**：
  1. 多数元素：使用唱票法（Boyer - Moore 投票算法）来解决。初始化一个候选元素和计数器，遍历数组，若当前元素与候选元素相同则计数器加 1，否则减 1。当计数器为 0 时，更换候选元素为当前元素并重置计数器。遍历结束后，候选元素即为多数元素。
  2. 只出现一次的数字：使用异或运算来解决。因为异或运算满足交换律和结合律，且任何数与 0 异或结果为其本身，相同的数异或结果为 0。遍历数组，将所有元素进行异或运算，最终结果就是只出现一次的数字。
### 9月16日
- **学习内容**：指针运用
- **完成题目**：
  1. 颜色分类：使用三个指针遍历数组来解决。通过三个指针将数组分为三个区域，分别对应三种颜色，在遍历过程中不断调整元素位置，使得相同颜色的元素相邻排列。
  2. 寻找重复数：使用快慢指针的方法。将数组看作链表，利用快慢指针的特性，快指针每次移动两步，慢指针每次移动一步，当快慢指针相遇后，再用一个新指针从起点出发，与慢指针同步移动，相遇点即为重复的数字。


### 9月19日
- **学习内容**：矩阵操作
- **完成题目**：
  1. 螺旋矩阵：按顺时针螺旋顺序遍历矩阵。可以通过设定上下左右四个边界，按照从左到右、从上到下、从右到左、从下到上的顺序依次遍历矩阵元素，每遍历完一个方向后调整相应的边界。
  2. 矩阵置零：可以使用两个标记数组分别记录每一行和每一列是否需要置零。先遍历矩阵，标记需要置零的行和列，然后再次遍历矩阵，根据标记将对应的行和列置零。也可以使用矩阵的第一行和第一列作为标记数组，以节省空间。
