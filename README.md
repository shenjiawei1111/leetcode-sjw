# LeetCode 解题记录

这是我在 LeetCode 上刷题的解题记录仓库，包含各种算法和数据结构相关题目的解答。

## 项目结构
## 学习日志

### 8月23日
- **学习内容**：哈希表
- **完成题目**：LeetCode 热题 100
  1. 两数之和：使用哈希表存储已遍历过的数字及其索引，对于每个数字，检查目标值与当前数字的差值是否在哈希表中，若存在则返回对应索引。
  2. 字母异位分组：将每个字符串排序后作为键，原字符串作为值存入哈希表，最后收集所有值即可得到分组结果。
  3. 最长连续序列：先将所有数字存入集合，遍历每个数字时，若该数字的前一个数不在集合中，则开始向后查找连续的数字，统计最长长度。

### 8月24日
- **学习内容**：双指针
- **完成题目**：LeetCode 热题 100
  1. 移动零：使用双指针，一个指针遍历数组，另一个指针记录非零元素的位置，将非零元素移到前面，最后将剩余位置置零。
  2. 盛最多水的容器：使用左右双指针，计算当前面积，然后移动较短的指针，不断更新最大面积。
  3. 三数之和：先排序，固定一个数，使用左右双指针在剩余数组中找和为目标值的两个数，注意跳过重复元素。
### 8月25日

- **学习内容**：滑动窗口
- **完成题目**：
  1. 无重复字符的最长子串：使用滑动窗口和哈希集合来解决。维护一个滑动窗口表示当前无重复字符的子串，右指针不断向右移动，将字符加入集合，若遇到重复字符，则移动左指针并从集合中移除字符，直到重复字符被移除，同时更新最长子串的长度。
  2. 找到字符串中所有字母异位词：使用滑动窗口和哈希表来统计字符频率。先统计模式串的字符频率，然后在主串上使用固定大小的滑动窗口，统计窗口内字符频率，若与模式串频率一致，则记录窗口起始位置。
### 8月26日
- **学习内容**：子串题型、链表
- **完成题目**：
  1. 和为k的子数组：使用前缀和与哈希表来解决。遍历数组，计算当前的前缀和，将前缀和出现的次数记录在哈希表中。对于每个前缀和，检查前缀和减去k的值是否在哈希表中，若存在则将对应次数累加到结果中，最后更新当前前缀和的出现次数。
  2. 相交链表：有多种解法，一种方法是使用双指针。分别让两个指针从两个链表头开始遍历，当一个指针到达链表末尾时，将其重定向到另一个链表的头节点。这样两个指针会在相交节点相遇，若不相交则最终都为null。

### 8月27日
- **学习内容**：普通数组、链表
- **完成题目**：
  1. 最大子数组和：使用动态规划来解决。遍历数组，维护一个当前最大子数组和变量，对于每个元素，决定是将其加入当前子数组还是以该元素开始新的子数组，同时更新全局最大子数组和。
  2. 回文链表：先找到链表的中间节点，然后反转后半部分链表，再将前半部分和反转后的后半部分逐一比较节点值，若都相同则为回文链表，比较完成后可按需恢复链表结构。
  3. 反转链表：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
### 8月28日
- **学习内容**：链表操作、数组合并
- **完成题目**：
  1. 反转链表1：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
  2. 反转链表2：此问题是反转链表的进阶版，通常需要先定位到需要反转的区间，再利用类似反转链表1的方法对该区间内的节点进行反转，注意处理好区间首尾节点与其他部分的连接。
  3. 环形链表：使用快慢指针的方法，快指针每次移动两步，慢指针每次移动一步。若链表中存在环，快指针最终会追上慢指针；若不存在环，快指针会先到达链表末尾。
  4. 合并数组：根据数组是否有序有不同的处理方式。若数组有序，可以使用双指针法，分别从两个数组的起始位置开始比较元素大小，将较小的元素依次放入新数组或目标数组中；若数组无序，可能需要先排序再合并，或者根据具体需求采用其他策略。

### 9月2日
- **学习内容**：数组轮转、数组乘积、链表求和
- **完成题目**：
  1. 轮转数组：可以通过三次反转数组来实现。先反转整个数组，再反转前 k 个元素，最后反转剩下的元素，这样就能得到数组轮转 k 次后的结果，其中 k 需要对数组长度取模以避免不必要的操作。
  2. 除自身以外数组的乘积：使用前缀积和后缀积的方法。先计算每个位置的前缀积，即该位置之前所有元素的乘积，再计算每个位置的后缀积，即该位置之后所有元素的乘积，最后将对应位置的前缀积和后缀积相乘，就可以得到除自身以外数组的乘积，且不需要额外的空间复杂度。
  3. 链表的两数之和：从两个链表的头节点开始遍历，逐位相加节点的值，并考虑进位。创建一个新的链表来存储相加的结果，若其中一个链表遍历完，另一个链表还有剩余节点，则继续处理剩余节点并加上进位，最后若还有进位则在结果链表末尾添加一个值为 1 的节点。

### 9月3日
- **学习内容**：二叉树的结构和四种遍历方式
- **完成题目**：
  1. 二叉树的中序遍历：可以使用递归或迭代的方法。递归方法直接按照左子树 - 根节点 - 右子树的顺序递归遍历；迭代方法使用栈来模拟递归过程，先将左子节点不断入栈，直到左子节点为空，然后弹出栈顶节点访问，再处理其右子节点。
  2. 二叉树的最大深度：可以使用递归或广度优先搜索（BFS）的方法。递归方法中，树的最大深度等于左子树和右子树最大深度的最大值加 1；BFS 方法使用队列进行层序遍历，每遍历一层深度加 1，直到队列为空。
### 9月4日
- **学习内容**：二叉树的反转与对称判断
- **完成题目**：
  1. 反转二叉树：可以使用递归或迭代的方法。递归方法是交换当前节点的左右子树，然后递归地对左右子树进行同样的操作；迭代方法可使用队列或栈，将节点依次放入容器中，每次取出一个节点并交换其左右子树，直到容器为空。
  2. 对称二叉树：可以使用递归或迭代的方法。递归方法中，判断左右子树是否对称，需要比较左子树的左节点和右子树的右节点，以及左子树的右节点和右子树的左节点是否对称；迭代方法使用队列或栈，将对应的节点成对放入容器中，每次取出一对节点进行比较，若不相等则不对称，直到容器为空。
