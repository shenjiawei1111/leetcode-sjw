# LeetCode 解题记录

这是我在 LeetCode 上刷题的解题记录仓库，包含各种算法和数据结构相关题目的解答。

## 项目结构
## 学习日志

### 8月23日
- **学习内容**：哈希表
- **完成题目**：LeetCode 热题 100
  1. 两数之和：使用哈希表存储已遍历过的数字及其索引，对于每个数字，检查目标值与当前数字的差值是否在哈希表中，若存在则返回对应索引。
  2. 字母异位分组：将每个字符串排序后作为键，原字符串作为值存入哈希表，最后收集所有值即可得到分组结果。
  3. 最长连续序列：先将所有数字存入集合，遍历每个数字时，若该数字的前一个数不在集合中，则开始向后查找连续的数字，统计最长长度。

### 8月24日
- **学习内容**：双指针
- **完成题目**：LeetCode 热题 100
  1. 移动零：使用双指针，一个指针遍历数组，另一个指针记录非零元素的位置，将非零元素移到前面，最后将剩余位置置零。
  2. 盛最多水的容器：使用左右双指针，计算当前面积，然后移动较短的指针，不断更新最大面积。
  3. 三数之和：先排序，固定一个数，使用左右双指针在剩余数组中找和为目标值的两个数，注意跳过重复元素。
### 8月25日

- **学习内容**：滑动窗口
- **完成题目**：
  1. 无重复字符的最长子串：使用滑动窗口和哈希集合来解决。维护一个滑动窗口表示当前无重复字符的子串，右指针不断向右移动，将字符加入集合，若遇到重复字符，则移动左指针并从集合中移除字符，直到重复字符被移除，同时更新最长子串的长度。
  2. 找到字符串中所有字母异位词：使用滑动窗口和哈希表来统计字符频率。先统计模式串的字符频率，然后在主串上使用固定大小的滑动窗口，统计窗口内字符频率，若与模式串频率一致，则记录窗口起始位置。
### 8月26日
- **学习内容**：子串题型、链表
- **完成题目**：
  1. 和为k的子数组：使用前缀和与哈希表来解决。遍历数组，计算当前的前缀和，将前缀和出现的次数记录在哈希表中。对于每个前缀和，检查前缀和减去k的值是否在哈希表中，若存在则将对应次数累加到结果中，最后更新当前前缀和的出现次数。
  2. 相交链表：有多种解法，一种方法是使用双指针。分别让两个指针从两个链表头开始遍历，当一个指针到达链表末尾时，将其重定向到另一个链表的头节点。这样两个指针会在相交节点相遇，若不相交则最终都为null。

### 8月27日
- **学习内容**：普通数组、链表
- **完成题目**：
  1. 最大子数组和：使用动态规划来解决。遍历数组，维护一个当前最大子数组和变量，对于每个元素，决定是将其加入当前子数组还是以该元素开始新的子数组，同时更新全局最大子数组和。
  2. 回文链表：先找到链表的中间节点，然后反转后半部分链表，再将前半部分和反转后的后半部分逐一比较节点值，若都相同则为回文链表，比较完成后可按需恢复链表结构。
  3. 反转链表：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
### 8月28日
- **学习内容**：链表操作、数组合并
- **完成题目**：
  1. 反转链表1：可以使用迭代或递归的方法。迭代方法中，使用三个指针，分别记录前一个节点、当前节点和下一个节点，遍历链表时不断反转当前节点的指针指向；递归方法则是先递归处理后续节点，再调整当前节点指针指向。
  2. 反转链表2：此问题是反转链表的进阶版，通常需要先定位到需要反转的区间，再利用类似反转链表1的方法对该区间内的节点进行反转，注意处理好区间首尾节点与其他部分的连接。
  3. 环形链表：使用快慢指针的方法，快指针每次移动两步，慢指针每次移动一步。若链表中存在环，快指针最终会追上慢指针；若不存在环，快指针会先到达链表末尾。
  4. 合并数组：根据数组是否有序有不同的处理方式。若数组有序，可以使用双指针法，分别从两个数组的起始位置开始比较元素大小，将较小的元素依次放入新数组或目标数组中；若数组无序，可能需要先排序再合并，或者根据具体需求采用其他策略。

### 9月2日
- **学习内容**：数组轮转、数组乘积、链表求和
- **完成题目**：
  1. 轮转数组：可以通过三次反转数组来实现。先反转整个数组，再反转前 k 个元素，最后反转剩下的元素，这样就能得到数组轮转 k 次后的结果，其中 k 需要对数组长度取模以避免不必要的操作。
  2. 除自身以外数组的乘积：使用前缀积和后缀积的方法。先计算每个位置的前缀积，即该位置之前所有元素的乘积，再计算每个位置的后缀积，即该位置之后所有元素的乘积，最后将对应位置的前缀积和后缀积相乘，就可以得到除自身以外数组的乘积，且不需要额外的空间复杂度。
  3. 链表的两数之和：从两个链表的头节点开始遍历，逐位相加节点的值，并考虑进位。创建一个新的链表来存储相加的结果，若其中一个链表遍历完，另一个链表还有剩余节点，则继续处理剩余节点并加上进位，最后若还有进位则在结果链表末尾添加一个值为 1 的节点。

### 9月3日
- **学习内容**：二叉树的结构和四种遍历方式
- **完成题目**：
  1. 二叉树的中序遍历：可以使用递归或迭代的方法。递归方法直接按照左子树 - 根节点 - 右子树的顺序递归遍历；迭代方法使用栈来模拟递归过程，先将左子节点不断入栈，直到左子节点为空，然后弹出栈顶节点访问，再处理其右子节点。
  2. 二叉树的最大深度：可以使用递归或广度优先搜索（BFS）的方法。递归方法中，树的最大深度等于左子树和右子树最大深度的最大值加 1；BFS 方法使用队列进行层序遍历，每遍历一层深度加 1，直到队列为空。
### 9月4日
- **学习内容**：二叉树的反转与对称判断
- **完成题目**：
  1. 反转二叉树：可以使用递归或迭代的方法。递归方法是交换当前节点的左右子树，然后递归地对左右子树进行同样的操作；迭代方法可使用队列或栈，将节点依次放入容器中，每次取出一个节点并交换其左右子树，直到容器为空。
  2. 对称二叉树：可以使用递归或迭代的方法。递归方法中，判断左右子树是否对称，需要比较左子树的左节点和右子树的右节点，以及左子树的右节点和右子树的左节点是否对称；迭代方法使用队列或栈，将对应的节点成对放入容器中，每次取出一对节点进行比较，若不相等则不对称，直到容器为空。
### 9月5日
- **学习内容**：二叉树的层序遍历、二叉树的直径计算
- **完成题目**：
  1. 二叉树的层序遍历：使用广度优先搜索（BFS）的方法。借助队列来实现，先将根节点入队，然后不断从队列中取出节点，访问该节点，并将其左右子节点依次入队，直到队列为空。为了区分每一层的节点，可以在每次处理一层节点前记录当前队列的大小，处理完这一层的所有节点后再处理下一层。
  2. 二叉树的直径：可以使用递归的方法。二叉树的直径定义为树中任意两个节点路径长度中的最大值，而这条路径可能不经过根节点。递归计算每个节点的左右子树的最大深度，直径等于左右子树最大深度之和，在递归过程中更新全局最大直径。
### 9月6日
- **学习内容**：二叉搜索树
- **完成题目**：
  1. 二叉搜索树：构建二叉搜索树，插入节点时，若插入值小于当前节点值，则插入到左子树；若大于当前节点值，则插入到右子树。
  2. 验证二叉搜索树：可以使用递归或中序遍历的方法。递归方法需要传递上下界，确保每个节点的值在合法范围内；中序遍历二叉搜索树会得到一个严格递增的序列，可通过判断遍历结果是否递增来验证。

### 9月8日
- **学习内容**：二叉搜索树、二叉树右视图
- **完成题目**：
  1. 二叉搜索树中第k个元素：利用中序遍历的方法，因为二叉搜索树的中序遍历结果是一个严格递增的序列，即按照左子树 - 根节点 - 右子树的顺序遍历。在遍历过程中记录遍历节点的数量，当遍历到第k个节点时，该节点的值就是所求的第k个元素。
  2. 二叉树的右视图：使用层序遍历的方法。借助队列实现层序遍历，在每次处理一层节点时，将该层的最后一个节点（即最右边的节点）的值记录下来，直到队列为空，最终记录的值按顺序排列就是二叉树的右视图。
### 9月9日
- **学习内容**：二叉树展开、二叉树构造
- **完成题目**：
  1. 二叉树展开为链表：把根节点的右子树挂到左子树最右边的断点，再把左子树换到根节点的右子树位置，依次往下处理。
  2. 从前序与中序遍历序列构造二叉树：用前序遍历序列确定根节点，再利用中序遍历序列划分左右子树，递归构建二叉树。
### 9月10日
- **学习内容**：二叉树路径总和、二叉树的公共祖先
- **完成题目**：
  1. 二叉树路径总和：使用二层递归嵌套的方法。外层递归用于移动 `root` 节点，内层递归计算从每个节点出发能达到指定路径和的个数。
  2. 二叉树的公共祖先：采用从上到下递归遍历的方法。先判断每个根节点是否为 `p` 和 `q`，若不是，则判断其左右子节点与 `p`、`q` 的关系。
### 9月11日
- **学习内容**：链表删除、链表交换
- **完成题目**：
  1. 删除链表的倒数第N个结点：使用快慢指针的方法，借助哨兵节点简化头节点处理，快指针先走n步，然后慢指针和快指针一起移动，当快指针为null时，慢指针所指节点的下一个节点就是要删除的节点。
  2. 两两交换链表的节点：借助哨兵节点简化头节点处理，本质是简单的链表指向操作，通过调整相邻节点的指针指向完成交换。
  
### 9月12日
- **学习内容**：链表排序、随机链表复制
- **完成题目**：
  1. 排序列表：将链表节点的值提取到列表中，对列表进行排序，再根据排序后的列表重新构建链表。
  2. 随机链表的复制：使用哈希表存储原节点和对应的新节点。遍历原链表，先创建新节点并与原节点建立映射关系，再遍历一次原链表，根据哈希表为新链表的节点接上正确的指针，包括 next 和 random 指针。
### 9月13日（请根据实际日期修改）
- **学习内容**：栈的应用
- **完成题目**：
  1. 有效的括号：使用栈和哈希表来解决。首先创建一个哈希表，将右括号作为键，对应的左括号作为值。遍历字符串，若遇到左括号则将其压入栈中；若遇到右括号，判断栈顶元素是否为该右括号对应的左括号，若是则弹出栈顶元素，否则返回无效。遍历结束后，若栈为空则字符串有效，否则无效。
  2. 字符串解码：使用栈来解决。遍历字符串，当遇到数字时，解析出完整的数字作为重复次数；当遇到 '[' 时，将当前解析的字符串和重复次数压入栈中，并重置当前字符串；当遇到 ']' 时，弹出栈顶的重复次数和之前的字符串，将当前字符串重复相应次数后拼接到之前的字符串后面；当遇到普通字符时，直接添加到当前字符串。最终得到解码后的字符串。

### 9月14日（请根据实际日期修改）
- **学习内容**：栈的应用
- **完成题目**：
  1. 每日温度：使用单调栈来解决。遍历温度数组，维护一个栈存储数组的索引，栈中索引对应的温度是单调递减的。对于每个温度，如果当前温度大于栈顶索引对应的温度，就计算当前索引与栈顶索引的差值，这个差值就是栈顶索引对应的温度需要等待的天数，然后弹出栈顶元素，直到不满足条件或栈为空，最后将当前索引入栈。
  2. 最小栈：设计一个栈结构，除了支持常规的栈操作外，还能在常数时间内获取栈中的最小元素。可以使用辅助栈来实现，辅助栈的栈顶始终保存当前栈中的最小元素。入栈时，如果新元素小于等于辅助栈栈顶元素，则将新元素也压入辅助栈；出栈时，如果出栈元素等于辅助栈栈顶元素，则辅助栈也弹出栈顶元素。
### 9月15日
- **学习内容**：位运算、投票算法
- **完成题目**：
  1. 多数元素：使用唱票法（Boyer - Moore 投票算法）来解决。初始化一个候选元素和计数器，遍历数组，若当前元素与候选元素相同则计数器加 1，否则减 1。当计数器为 0 时，更换候选元素为当前元素并重置计数器。遍历结束后，候选元素即为多数元素。
  2. 只出现一次的数字：使用异或运算来解决。因为异或运算满足交换律和结合律，且任何数与 0 异或结果为其本身，相同的数异或结果为 0。遍历数组，将所有元素进行异或运算，最终结果就是只出现一次的数字。
### 9月16日
- **学习内容**：指针运用
- **完成题目**：
  1. 颜色分类：使用三个指针遍历数组来解决。通过三个指针将数组分为三个区域，分别对应三种颜色，在遍历过程中不断调整元素位置，使得相同颜色的元素相邻排列。
  2. 寻找重复数：使用快慢指针的方法。将数组看作链表，利用快慢指针的特性，快指针每次移动两步，慢指针每次移动一步，当快慢指针相遇后，再用一个新指针从起点出发，与慢指针同步移动，相遇点即为重复的数字。


### 9月19日
- **学习内容**：矩阵操作
- **完成题目**：
  1. 螺旋矩阵：按顺时针螺旋顺序遍历矩阵。可以通过设定上下左右四个边界，按照从左到右、从上到下、从右到左、从下到上的顺序依次遍历矩阵元素，每遍历完一个方向后调整相应的边界。
  2. 矩阵置零：可以使用两个标记数组分别记录每一行和每一列是否需要置零。先遍历矩阵，标记需要置零的行和列，然后再次遍历矩阵，根据标记将对应的行和列置零。也可以使用矩阵的第一行和第一列作为标记数组，以节省空间。

### 9月21日
- **学习内容**：矩阵操作
- **完成题目**：
  1. 旋转图像：先转置矩阵，再将每一行的元素首尾调换位置。
  2. 搜索二维矩阵：从矩阵的右上角或者左下角开始遍历查找目标值。
  
### 9月22日
- **学习内容**：二分查找
- **完成题目**：
  1. 搜索二维矩阵：从矩阵的右上角或者左下角开始遍历查找目标值，也可将矩阵展平为一维数组后使用二分查找。
  2. 搜索插入位置：先将矩阵展平为一维数组，再使用二分查找算法确定目标值的插入位置。该过程运用了二分法思想。
  
### 9月23日
- **学习内容**：二分查找进阶
- **完成题目**：
  1. 在排序数组中查找元素的第一个和最后一个位置：先使用二分查找找到目标值 `target`，再分别向左和向右查找其左边界和右边界。
  2. 搜索旋转排序数组：先判断左右哪一侧是有序的，再判断目标值 `target` 是否在有序的这一侧，然后根据情况缩小查找范围进行二分查找。

### 9月24日
- **学习内容**：图的遍历
- **完成题目**：
  1. 岛屿数量：使用深度优先搜索（DFS）的思路。遍历二维网格，当遇到陆地（值为 1）时，将其标记为已访问（值置为 0），并递归地对其上下左右相邻的陆地进行同样的操作，每进行一次这样的操作就意味着发现一个新的岛屿，最终统计岛屿数量。
  2. 腐烂的橘子：使用广度优先搜索（BFS）的方法。先将所有腐烂的橘子位置加入队列，同时统计新鲜橘子的数量。然后从队列中取出腐烂的橘子，将其上下左右相邻的新鲜橘子变为腐烂状态，并加入队列，每一轮处理相当于过了一分钟，直到队列为空。最后判断新鲜橘子是否全部腐烂，若全部腐烂则返回所需的分钟数，否则返回 -1。

### 9月25日
- **学习内容**：图的拓扑排序、二分查找
- **完成题目**：
  1. 课程表：使用入度结合广度优先算法来解决。首先统计每个节点的入度，将入度为 0 的节点加入队列。然后不断从队列中取出节点，将其邻接节点的入度减 1，若邻接节点的入度变为 0 则加入队列。遍历结束后，若所有节点都被处理过，则说明课程表无环，否则有环。
  2. 寻找旋转排列数组中的最小值：使用二分查找的方法。通过比较中间元素和右边界元素的大小，判断最小值在左半部分还是右半部分，不断缩小查找范围，最终找到最小值。

### 9月26日
- **学习内容**：动态规划基础
- **完成题目**：
  1. 爬楼梯：基于动态规划的思想，使用滚动变量来优化空间复杂度。通过维护几个变量来记录前几个状态的值，避免使用数组存储所有状态，从而完成问题求解。
  2. 杨辉三角：使用 `new Array` 提前分配内存，减少内存开销。在构建杨辉三角的每一行时，预先创建指定长度的数组，避免动态调整数组大小带来的额外开销。
### 9月27日
- **学习内容**：动态规划进阶
- **完成题目**：
  1. 打家劫舍：使用动态规划的思想，维护一个 dp 表。对于每间房屋，考虑偷或不偷两种情况，当前房屋的最大收益取决于前一间房屋不偷的最大收益加上当前房屋的价值，或者前一间房屋偷的最大收益，取两者中的最大值，后面的状态靠前面的状态规划。
  2. 完全平方数：使用动态规划的方法，构建一个 dp 表。初始化 dp 数组，对于每个数，遍历所有可能的完全平方数，更新 dp 值为当前 dp 值和 dp[当前数 - 完全平方数] + 1 中的较小值，同样是后面的状态依赖前面的状态来规划。
  
### 9月28日
- **学习内容**：动态规划应用
- **完成题目**：
  1. 零钱兑换：使用动态规划的方法，构建一个 dp 表。初始化 dp 数组，数组长度为目标金额加 1，初始值设为一个较大值（如正无穷或目标金额 + 1），dp[0] 设为 0。对于每个金额，遍历所有硬币面额，若硬币面额小于等于当前金额，则更新 dp 值为当前 dp 值和 dp[当前金额 - 硬币面额] + 1 中的较小值，最终 dp[目标金额] 即为所需的最少硬币数。若 dp[目标金额] 仍为初始值，则表示无法凑出目标金额。

### 9月29日
- **学习内容**：动态规划应用
- **完成题目**：
  1. 单词拆分：使用动态规划的方法，构建一个 dp 数组。初始化 `dp[0]` 为 `true`，表示空字符串可以被拆分。对于每个位置 `i`，遍历 `0` 到 `i-1` 的所有位置 `j`，若 `dp[j]` 为 `true` 且子串 `s.substring(j, i)` 在单词字典中，则 `dp[i]` 为 `true`。最终 `dp[s.length()]` 即为结果。
  2. 最长递增子序列：使用动态规划的方法，构建一个 dp 数组，`dp[i]` 表示以第 `i` 个元素结尾的最长递增子序列的长度。初始化 `dp` 数组所有元素为 1，遍历数组，对于每个元素，再遍历其之前的所有元素，若当前元素大于之前的某个元素，则更新 `dp[i]` 为 `Math.max(dp[i], dp[j] + 1)`，最后找出 `dp` 数组中的最大值即为结果。

### 10月9日
- **学习内容**：动态规划应用
- **完成题目**：
  1. 分割等和子集：使用动态规划的思路，可将问题转化为判断是否能从数组中选取若干元素，使得它们的和等于数组总和的一半。构建一个 dp 数组，dp[j] 表示能否凑出和为 j 的子集，通过遍历数组元素，更新 dp 数组。
  2. 乘积最大子数组：使用动态规划的方法，由于存在负数会使最大乘积变为最小乘积，最小乘积变为最大乘积，所以需要同时维护当前的最大乘积和最小乘积。遍历数组，对于每个元素，计算以该元素结尾的最大乘积和最小乘积，不断更新全局最大乘积。在计算过程中要注意负数情况，每次都需找到当前的最大值和最小值。

### 10月10日
- **学习内容**：动态规划应用
- **完成题目**：
  1. 不同路径：使用动态规划的方法，生成二维 `dp` 表。`dp[i][j]` 表示从起点到第 `i` 行第 `j` 列位置的不同路径数量，对于第一行和第一列，路径数量都为 1，其余位置的路径数量等于其上方和左方位置的路径数量之和，即 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
  2. 最小路径和：使用动态规划的思想，构建二维 `dp` 表。`dp[i][j]` 表示从起点到第 `i` 行第 `j` 列位置的最小路径和，对于第一行和第一列，路径和是前一个位置的路径和加上当前位置的值，其余位置的最小路径和为上方和左方位置的最小路径和中的较小值加上当前位置的值，即 `dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。

### 10月13日
- **学习内容**：回溯算法
- **完成题目**：
  1. 全排列：使用回溯的思想。通过递归和回溯的方式，不断尝试所有可能的排列组合。在递归过程中，使用一个标记数组来记录哪些元素已经被使用过，每次递归选择一个未使用的元素加入当前排列，递归返回后撤销选择，继续尝试其他元素。
  2. 子集：同样运用回溯的思想。从空集开始，递归地向子集中添加元素，每次递归后撤销添加操作，以此生成所有子集。可以通过控制递归的起始位置来避免生成重复的子集。
